## PiPL resources

<br>
&#160;&#160;&#160;&#160;&#160;&#160;
Originating in Adobe Photoshop over a decade ago, Plug-In Property Lists, or PiPLs, are resources which provide basic information about a plug-in’s behavior, without executing the plug-in. PiPLs have been largely supplanted within After Effects by PF_Cmd_GLOBAL_SETUP and dynamic outflags. However, for archaeological reasons, the behaviors indicated during PF_Cmd_GLOBAL_SETUP must agree with those in the PiPL.

&#160;&#160;&#160;&#160;&#160;&#160;
A PiPL specifies the entry point of a plug-in, as well as the plug-in’s match name. The match name is a unique, constant identifier, unlike a plug-in’s display name, which may be changed dynamically.

&#160;&#160;&#160;&#160;&#160;&#160;
In the interest of cross-platform compatibility, use a single .r file for both Mac OS and Windows versions of your plug-in, like the samples do. PiPL properties must always be in Mac OS-specific byte order. On Windows, PiPLs are compiled by processing a .r file through pipltool.exe, which converts the .r file into a binary .rc file. The Windows sample projects all contain custom build steps which generate a .rc file, using a cross-platform .r file and our cnvtpipl.exe command line utility. Base your development on an existing sample plug-in and the build step will be correctly implemented.

### Entry Point

&#160;&#160;&#160;&#160;&#160;&#160;
Your plug-in’s entry point is exported through the PiPL on Windows and Mac OS. If the plug-in supports multiple platforms (e.g. 32-bit Windows and Intel Macs), then multiple entry points must be defined in the PiPL. There is no need for a Windows .def file or manual exports, unless you’re also designating some other OS-specific entry point. The macros defined in `entry.h` (in the `\SDK\Examples\Headers directory`) take care of exporting each sample’s entry point function. XCode seems overly concerned about the prospect of a `main()` function returning a long; all the sample projects’ entry point functions have been changed to the seemingly innocuous `EntryPointFunc()`.

### PiPL resources and Microsoft Visual Studio

&#160;&#160;&#160;&#160;&#160;&#160;
To use resources from Microsoft Visual Studio .NET with pipltool-generated resources, #include the output of the custom build steps into the Microsoft-generated .rc file.

```c++
// in file WhizBang.rc, generated by .NET.
#include “WhizBang_PiPL_temp.rc” // pipltool.exe’s output
```

&#160;&#160;&#160;&#160;&#160;&#160;
If modifying a sample plug-in, change the name of the file generated by pipltool.exe to something like WhizBang_PiPL_temp.rc, or it will overwrite the Microsoft resources each time you build; not good.

### Multiple PiPLs

&#160;&#160;&#160;&#160;&#160;&#160;
It is possible, but not recommended, to include multiple plug-ins (both AEGPs and effects) in the same file, using multiple PiPLs. If there are PiPLs for both AEGPs and effects in the same file, the AEGPs must come first!
No other hosts (not even Premiere Pro) support multiple PiPLs pointing to multiple effects within the same .dll or code fragment. Also, if you need to update one plug-in, do you really want to ship a new build of all your plug-ins? We recommend one PiPL, and one plug-in, per code fragment.

### Super Secret PiPL bit

&#160;&#160;&#160;&#160;&#160;&#160;
For those of you who use C++ and simply must keep your plug-ins loaded all the time (to avoid having your v-tables trashed, among other hazards), set the PiPL’s AE_Reserved_Info member to 8. Over the years we’ve been quite stringent, insisting that plug-ins be good memory citizens and respond gracefully to getting unloaded. We know there are cases in which being unloaded with no warning can really ruin a plug-in’s day (and v-tables), and so have provided this work-around. Be nice, perform scrupulous memory management, and only use your powers for good.

### Why do I need to know all this?

&#160;&#160;&#160;&#160;&#160;&#160;
You don’t; After Effects does. If you follow our advice and base your projects on the SDK samples, you can simply change the .r file containing your PiPL definition(s), and your plug-in’s resources will be automagically updated the next time you build. Feel the love. Or, if you ever tinker with the custom build steps, feel the pain.

***
## PiPL资源

&#160;&#160;&#160;&#160;&#160;&#160;
此物起源于十年前的PS，主要提供了`插件属性列表[Plug-In Property Lists]`、`PiPLs`等作为资源，这些资源包含了插件在没有被执行的时候的行为的基本信息。`PiPLs`已经在`After Effects`中被`PF_Cmd_GLOBAL_SETUP`和`dynamic outflags`大量取代。然而，由于历史缘故，`PF_Cmd_GLOBAL_SETUP`中指示的行为必须与`PiPL`中的行为一致。

一个PiPL指定插件的入口点和其匹配名称。这个匹配名称是在插件插件之中时唯一的，相当于身份证的作用（实质上是插件在AE中的内部名称），与在AE中显示的可改变的名称不同。

为了兼容跨平台的特性，在插件的`Mac OS`和`Windows`版本中使用`.r文件`来生成对应平台的`PiPL资源`。PiPL属性在`Mac OS`下比如按照特地ingde字节顺序。在`Windows`下，`PiPL资源`则通过`pipltool.exe`编译`.r文件`所得。在`Windows`下的样例工程全部包含了生成所需的`.rc文件`的`自定义生成步骤[custom build steps]`，通过此命令可以根据`.r文件`生成对应的`.rc文件`，另外还有`cnvtpipl.exe`命令行工具。基于你目前正在依赖的已经存在的样例插件和`生成步骤[build step]`将可以完成正确的插件构建流程。

### 入口点

&#160;&#160;&#160;&#160;&#160;&#160;
在`Windows`和`Mac OS`中你的插件入口点是一个由`PiPL资源`来导出的。如果此插件支持多个平台（如 `32-bit Windows`和`Intel Macs`）,那么必须在PiPL资源中指定多个入口点。这里不须使用`.def 文件`或手动将入口点函数导出，除非你还打算展示一些其他特定操作系统的入口点。通过在`\SDK\Examples\Headers directory`目录下的`entry.h`中定义的宏来导出每个样例工程的入口点函数。XCode似乎过于关心`main()`函数的返回值过长；所有样例工程的入口带你函数似乎已经改成了看似无关要紧的`EntryPointFunc()`。

### 入口点

&#160;&#160;&#160;&#160;&#160;&#160;
（在样例工程中）使用的来自VS .Net提供的资源是由`pipltool`工具生成的，这是通过`自定义生成步骤[custom build steps]`功能来（让VS编译`.r文件`）生成`.rc文件`的。

```c++
// in file WhizBang.rc, generated by .NET.
#include “WhizBang_PiPL_temp.rc” // pipltool.exe’s output
```

&#160;&#160;&#160;&#160;&#160;&#160;
如果修改一个样例插件，它会改变通过`pipltool.exe`生成的类似`WhizBang_PiPL_temp.rc`的文件，或者它会在你每次构建项目的时候重写，这是不太推荐的。

### 多个PiPL资源

&#160;&#160;&#160;&#160;&#160;&#160;
在`AEGP`和`effects`中，在相同文件中使用`多个PiPL资源`来包含了`多个插件`，这个是可能是实现的，但是并不推荐这样做。如果使用了同一个`PiPL资源`文件来同时处理`AEGP`和`Effect`插件，那么必定是`AEGPs`先工作。

在相同的dll或代码片段中没有其他的主机(甚至包括`Premiere Pro`)支持多个PiPL资源指向多个相同的特效。另外，如果你需要更新某个插件时，你真的想要发布一个新构建的插件?我们建议一个PiPL资源对应一个插件和代码片段。

### 一个关于 PiPL bit的超级秘密

&#160;&#160;&#160;&#160;&#160;&#160;
对于那些使用c++和必须(避免你的`v-tables`被破坏,其他危险来)始终保持你的插件能够正常被加载的你而言，设置PiPL的`AE_Reserved_Info`成员到**8**比较好。多年以来我们一直很严格地控制版本演进,并坚持优雅地处理插件的内存管理和插件卸载。我们深知的确存在（插件）在没有警告的情况下被卸载真的会毁了一个插件的一天(和`v-tables`),所以提供了这个变通方法。幸好,插件在你的使用权限下可以把内存管理得一丝不苟。

### 为什么我需要了解这些信息呢?

&#160;&#160;&#160;&#160;&#160;&#160;
不了解AE（内部）是如何做的是不行的。如果你跟着我们的建议在SDK样例工程中构建了你的项目基础，那么（通常情况下）你会简单地修改定义了`PiPL资源`的`.r文件`的，并且你的插件资源文件将会在下次构建项目的时候会被自动更新（简而言之那个`.rc文件`会随着每次工程构建的时候，通过`pipltool.exe`把`.r文件`处理后更新的），如果你曾经试过自己来添加这个自定义生成步骤的话，那将会异常头疼的。

>个人理解：`PiPL资源`包含了各种AE插件类型的标记，并且提供了诸如入口点函数名的识别、插件在AE内部的身份识别标识的定义等数据，对于插件开发者而言，非常重要，如果一个AE插件没有`PiPL资源`或`PiPL资源`内定义的各种信息不合法的情况下，AE将会无法正常加载此插件。另外，由于不同平台对程序资源文件的识别有所差异，因此，官方已经将`PiPL资源`所需的各项数据信息通通放置在`.r文件`之中了，这样一来，就可以使用官方提供的`pipltool.exe`来根据平台不同和头文件不同来自动生成相应的平台标准化的资源文件了（比如在`Windows`平台下，用`pipltool.exe`会将`.r文件`转换成`.rc文件`，然后交由VS来编译进插件内），不过由于这个转换过程是在自定义生成命令下执行的，手动设置比较麻烦，因此官方也倡议直接在提供的样例工程上面改。当然，还有其他一些细节信息，比如官方推荐为每个插件专门定义一个`PiPL资源`，一对一，不要重复。虽然同一份`PiPL资源`也可以被多个插件利用；通过在`PiPL资源`中指定同一个插件也是可以作为`AEGP类型`和`Effect类型`的，但是官方并不推荐这样做，因为这样做会引起插件管理的各种不服。